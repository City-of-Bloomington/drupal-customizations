<?php
/**
 * @copyright 2013 City of Bloomington, Indiana
 * @license http://www.gnu.org/licenses/agpl.txt GNU/AGPL, see LICENSE.txt
 * @author Cliff Ingham <inghamn@bloomington.in.gov>
 */
function cob_node_siblings(array &$node)
{
	$field = 'field_'.$node['#bundle'];

	if (isset(   $node[$field]['#items'][0]['target_id'])) {
		$pid   = $node[$field]['#items'][0]['target_id'];
		$query = new EntityFieldQuery();

		$query->entityCondition('entity_type', 'node')
				->entityCondition('bundle', $node['#bundle'])
				->propertyCondition('status', 1)
				->propertyCondition('nid', $node['#node']->nid, '<>')
				->fieldCondition($field, 'target_id', $pid);
		$results = $query->execute();
		if (!empty($results['node'])) {
			return node_load_multiple(array_keys($results['node']));
		}
	}
}

/**
 * Returns nodes of the given type that refer to the given node
 *
 * Pass in the current node and specify what type of related nodes
 * you're looking for.  Content type for $bundle must have a
 * field reference to the content type of the current node.
 *
 * The $bundle type nodes might be in a hiearchy.  In that case,
 * you can also specify if you want only the top level nodes of
 * that content type.  By default, nodes from any level in the
 * hiearchy will be returned.
 *
 * @param array $node The current node
 * @param string $bundle The content type of nodes to return
 * @param bool $top_level_only
 * @return array An array of node objects
 */
function cob_node_references(array &$node, $bundle, $top_level_only=false)
{
	$current_type = $node['#bundle'];
	$field_data_table = "field_data_field_$current_type";
	if (db_table_exists($field_data_table)) {
		$sql = "select l.entity_id as nid from $field_data_table l";
		if ($top_level_only) { $sql.=" left join field_data_field_$bundle p on (p.entity_type='node' and l.entity_id=p.entity_id)"; }
		$sql.= " where l.field_{$current_type}_target_id=? and l.bundle='$bundle'}";
		if ($top_level_only) { $sql.=" and p.field_{$bundle}_target_id is null"; }

		$results = db_query($sql, array($node['#node']->nid));

		return cob_load_nodes_from_results($results);
	}
}

/**
 * @param array $node The current node
 * @param string $bundle Then content type of nodes to return
 * @return array An array of node objects
 */
function cob_nodes_related_by_topics (array &$node, $bundle)
{
	$current_type = $node['#bundle'];

	$sql = "select r.entity_id as nid
			from field_data_field_topics t
			join field_data_field_topics r using (field_topics_tid)
			where t.bundle=:current_type and t.entity_id=:nid
			and r.entity_id!=:rnid
			and r.bundle=:bundle";
	$results = db_query($sql, [
		'current_type'=>$current_type,
		'nid' =>$node['#node']->nid,
		'rnid'=>$node['#node']->nid,
		'bundle'=>$bundle
	]);

	return cob_load_nodes_from_results($results);
}

/**
 * Hydrates node objects from database results
 *
 * @param object $results A db_query object that has results
 * @return array An array of node objects
 */
function cob_load_nodes_from_results($results)
{
	$nids = array();
	foreach ($results as $row) {
		$nids[] = $row->nid;
	}
	$nodes = node_load_multiple($nids);
	return $nodes;
}

/**
 * Returns a parent node that has a logo
 *
 * This will iterate over all the possible node references
 * and return a reference to one of them that actually has a logo.
 * This is useful for rendering a logo from a node reference
 * when the current node does not have a logo defined on itself.
 *
 * @return object The node object
 */
function cob_logo_parent($node_id)
{
	$fields = ['program', 'department', 'board_or_commission', 'location'];
	foreach ($fields as $f) {
		$sql = "select f.field_{$f}_target_id
				from field_data_field_$f f
				join field_data_field_logo l on l.entity_type='node' and f.field_{$f}_target_id=l.entity_id
				where f.entity_type='node' and f.entity_id=?";
		$pid = db_query($sql, array($node_id))->fetchField();
		if ($pid) {
			return node_load($pid);
		}
	}
}
