<?php
/**
 * @copyright 2013 City of Bloomington, Indiana
 * @license http://www.gnu.org/licenses/agpl.txt GNU/AGPL, see LICENSE.txt
 * @author Cliff Ingham <inghamn@bloomington.in.gov>
 */
function cob_node_siblings(array &$node)
{
	if ($node['#bundle'] == 'location') {
		// Location parents are "Location Group" nodes
		$field = 'field_location_group';
	}
	else {
		// Normally, parents are of the same content type
		// as the current node
		$field = 'field_'.$node['#bundle'];
	}

	if (isset(   $node[$field]['#items'][0]['target_id'])) {
		$pid   = $node[$field]['#items'][0]['target_id'];
		$query = new EntityFieldQuery();

		$query  ->entityCondition('entity_type', 'node')
				->entityCondition('bundle', $node['#bundle'])
				->propertyCondition('status', 1)
				->propertyCondition('nid', $node['#node']->nid, '<>')
				->fieldCondition($field, 'target_id', $pid);
		$results = $query->execute();
		if (!empty($results['node'])) {
			return node_load_multiple(array_keys($results['node']));
		}
	}
}

/**
 * Returns nodes of the given type that refer to the given node
 *
 * Pass in the current node and specify what type of related nodes
 * you're looking for.  Content type for $bundle must have a
 * field reference to the content type of the current node.
 *
 * The $bundle type nodes might be in a hiearchy.  In that case,
 * you can also specify if you want only the top level nodes of
 * that content type.  By default, nodes from any level in the
 * hiearchy will be returned.
 *
 * @param array  $node   The current node
 * @param string $bundle The content type of nodes to return
 * @param string $order  The ordering for returned nodes (alphabetical, chronological)
 * @param int    $limit  How many nodes to return
 * @param bool   $top_level_only
 * @return array An array of node objects
 */
function cob_node_references(array &$node, $bundle, $top_level_only=false, $order=null, $limit=null)
{
	// All the rest of the field references can only reference one node
	// However, nodes that reference topics can link to unlimited topics
	// So, the fieldname for the topic references is plural
	$current_type = $node['#bundle'];
	if ($current_type == 'topic') { $current_type.= 's'; }

	$field_table  = "field_data_field_$current_type";
	$bundle_table = "field_data_field_$bundle";

	$bundle_table_exists = db_table_exists($bundle_table);

	if (db_table_exists($field_table)) {
		$sql =     "select referencing.entity_id as nid from $field_table referencing
					join node on referencing.entity_id=node.nid";
		if ($top_level_only && $bundle_table_exists) {
			$sql.= " left join $bundle_table parent
					 on (parent.entity_type='node' and referencing.entity_id=parent.entity_id)";
		}
		$sql.=     " where referencing.field_{$current_type}_target_id=?
					   and referencing.bundle='$bundle'}
					   and node.status=1";
		if ($top_level_only && $bundle_table_exists) {
			$sql.= "   and parent.field_{$bundle}_target_id is null";
		}
		if ($order) {
			switch ($order) {
				case 'alphabetical':
					$sql.= " order by node.title";
				break;

				case 'chronological':
					$sql.= " order by node.created desc";
				break;
			}
		}
		$limit = (int)$limit;
		if ($limit) {
			$sql.= " limit $limit";
		}

		$results = db_query($sql, array($node['#node']->nid));

		return cob_load_nodes_from_results($results);
	}
}

/**
 * @param array $node The current node
 * @param string $bundle Then content type of nodes to return
 * @return array An array of node objects
 */
function cob_nodes_related_by_topics (array &$node, $bundle)
{
	$current_type = $node['#bundle'];

	$sql = "select referencing.entity_id as nid
			from field_data_field_topics topic
			join field_data_field_topics referencing using (field_topics_target_id)
			join node on referencing.entity_id=node.nid
			where topic.bundle=:current_type and topic.entity_id=:nid
			  and referencing.entity_id!=:rnid
			  and referencing.bundle=:bundle
			  and node.status=1";
	$results = db_query($sql, [
		'current_type'=>$current_type,
		'nid' =>$node['#node']->nid,
		'rnid'=>$node['#node']->nid,
		'bundle'=>$bundle
	]);

	return cob_load_nodes_from_results($results);
}

/**
 * Hydrates node objects from database results
 *
 * @param object $results A db_query object that has results
 * @return array An array of node objects
 */
function cob_load_nodes_from_results($results)
{
	$nids = array();
	foreach ($results as $row) {
		$nids[] = $row->nid;
	}
	$nodes = node_load_multiple($nids);
	return $nodes;
}

/**
 * Returns a parent node that has a logo
 *
 * This will iterate over all the possible node references
 * and return a reference to one of them that actually has a logo.
 * This is useful for rendering a logo from a node reference
 * when the current node does not have a logo defined on itself.
 *
 * @return object The node object
 */
function cob_logo_parent($node_id)
{
	$fields = ['program', 'department', 'board_or_commission', 'location'];
	foreach ($fields as $f) {
		$sql = "select f.field_{$f}_target_id
				from field_data_field_$f f
				join field_data_field_logo l on l.entity_type='node' and f.field_{$f}_target_id=l.entity_id
				where f.entity_type='node' and f.entity_id=?";
		$pid = db_query($sql, array($node_id))->fetchField();
		if ($pid) {
			return node_load($pid);
		}
	}
}
