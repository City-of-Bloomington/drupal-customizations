<?php
/**
 * @copyright 2013-2015 City of Bloomington, Indiana
 * @license http://www.gnu.org/licenses/agpl.txt GNU/AGPL, see LICENSE.txt
 * @author Cliff Ingham <inghamn@bloomington.in.gov>
 */
/**
 * Override other module's theme information
 *
 * We're using this to use our own template for attachments.
 * Attachments are handled by the cmisro module (which talks
 * to Alfresco).
 *
 * @implements hook_theme_registry_alter
 * @param array $theme_registry The entire cache of theme registry information, post-processing.
 * @see https://api.drupal.org/api/drupal/modules!system!system.api.php/function/hook_theme_registry_alter/7
 */
function cob_theme_registry_alter(&$theme_registry)
{
    $theme_registry['cmisro_object']['path'] = drupal_get_path('theme', 'cob').'/templates';
}

/**
 * Fetches useful book information
 *
 * Looks up the parent node information for a book.
 *
 * @param array $book The book information from the node object
 * @return stdClass
 */
function cob_book_info(&$book)
{
    $sql = "select b.nid, n.type, n.title, c.field_category_tid
            from book b
            join node n on b.nid=n.nid
            join field_data_field_category c on b.nid=c.entity_id
            where b.mlid=?";
    $query = db_query($sql, [$book['plid']]);
    $results = $query->fetchAll();
    if ($results) {
        return current($results);
    }
}

/**
 * Return nodes attached to a term
 *
 * This is a replacement for the official taxonomy_select_nodes function
 * The official function does not support ordering alphabetically
 *
 * @override taxonomy_select_nodes
 * @see https://api.drupal.org/api/drupal/modules!taxonomy!taxonomy.module/function/taxonomy_select_nodes/7
 */
function cob_taxonomy_nodes($tid)
{
    $sql = "select t.nid from taxonomy_index t
            join node n on t.nid=n.nid
            where t.tid=?
            order by n.title";
    $query = db_query($sql, [$tid]);
    $results = $query->fetchAll();
    if ($results) {
        return cob_load_nodes_from_results($results);
    }
}

function cob_node_siblings(array &$node)
{
	if ($node['#bundle'] == 'location') {
		// Location parents are "Location Group" nodes
		$field = 'field_location_group';
	}
	else {
		// Normally, parents are of the same content type
		// as the current node
		$field = 'field_'.$node['#bundle'];
	}

	if (isset(   $node[$field]['#items'][0]['target_id'])) {
		$pid   = $node[$field]['#items'][0]['target_id'];
		$query = new EntityFieldQuery();

		$query  ->entityCondition('entity_type', 'node')
				->entityCondition('bundle', $node['#bundle'])
				->propertyCondition('status', 1)
				->propertyCondition('nid', $node['#node']->nid, '<>')
				->fieldCondition($field, 'target_id', $pid);
		$results = $query->execute();
		if (!empty($results['node'])) {
			return node_load_multiple(array_keys($results['node']));
		}
	}
}

/**
 * Returns nodes of the given type that refer to the given node
 *
 * Important:
 * This relies on having set up entity reference fields
 * that exactly match the machine names of content types.
 *
 * Pass in the current node and specify what type of related nodes
 * you're looking for.  Content type for $bundle must have a
 * field reference to the content type of the current node.
 *
 * The $bundle type nodes might be in a hiearchy.  In that case,
 * you can also specify if you want only the top level nodes of
 * that content type.  By default, nodes from any level in the
 * hiearchy will be returned.
 *
 * @param array  $node   The current node
 * @param string $bundle The content type of nodes to return
 * @param string $order  The ordering for returned nodes (alphabetical, chronological)
 * @param int    $limit  How many nodes to return
 * @param bool   $top_level_only
 * @return array An array of node objects
 */
function cob_node_references(array &$node, $bundle, $top_level_only=false, $order=null, $limit=null)
{
	// All the rest of the field references can only reference one node
	// However, nodes that reference topics can link to unlimited topics
	// So, the fieldname for the topic references is plural
	$nid          = $node['nid'];
	$current_type = $node['type'];

	if ($current_type == 'topic') { $current_type.= 's'; }

	$field_table  = "field_data_field_$current_type";

	if (db_table_exists($field_table)) {
		$sql =     "select referencing.entity_id as nid from $field_table referencing
					  join node on referencing.entity_id=node.nid
					 where referencing.field_{$current_type}_target_id=?
					   and referencing.bundle='$bundle'
					   and node.status=1";
		if ($order) {
			switch ($order) {
				case 'alphabetical':
					$sql.= " order by node.title";
				break;

				case 'chronological':
					$sql.= " order by node.created desc";
				break;
			}
		}
		$limit = (int)$limit;
		if ($limit) {
			$sql.= " limit $limit";
		}

		$results = db_query($sql, [$nid]);
		if ($top_level_only) {
			# Filter our references that have ancestors that also reference the current node
			$r = $results->fetchAllAssoc('nid');
			foreach (array_keys($r) as $reference_id) {
				if (cob_node_reference_has_parent($nid, $reference_id, $bundle, $current_type)) {
					unset($r[$reference_id]);
				}
			}
			$results = $r;
		}

		return cob_load_nodes_from_results($results);
	}
}

/**
 * Check for an ancestor that also references the current node
 *
 * Checks to see if a node-reference has an ancestor that also references
 * the same current node.  This assumes that you have already called
 * cob_node_references to get the full list of nodes that reference the
 * current node.
 *
 * Any ancestor that references the current node should be in the results
 * from that function.  So, we just need to iterate over the results
 * @return bool
 */
function cob_node_reference_has_parent($current_id, $child_id, $parent_bundle, $current_bundle )
{
	$sql = "select field_{$parent_bundle}_target_id as parent_id,r.field_{$current_bundle}_target_id as target
			from field_data_field_{$parent_bundle} p
			left join field_data_field_{$current_bundle} r on p.field_{$parent_bundle}_target_id=r.entity_id and r.field_{$current_bundle}_target_id=?
			where p.entity_id=?";
	$results = db_query($sql, array($current_id, $child_id));
	$r = $results->fetchAll();
	if (isset($r[0])) {
		//echo "Found a parent for this {$parent_bundle}\n";
		if ($r[0]->target) {
			//echo "Parent references the current node\n";
			return true;
		}
		else {
			//echo "We should check for more ancenstors\n";
			return cob_node_reference_has_parent($current_id, $r[0]->parent_id, $parent_bundle, $current_bundle);
		}
	}
	//echo "No more parents found\n";
}

/**
 * @param array $node The current node
 * @param string $bundle Then content type of nodes to return
 * @return array An array of node objects
 */
function cob_nodes_related_by_topics (array &$node, $bundle)
{
	$current_type = $node['#bundle'];

	$sql = "select referencing.entity_id as nid
			from field_data_field_topics topic
			join field_data_field_topics referencing using (field_topics_target_id)
			join node on referencing.entity_id=node.nid
			where topic.bundle=:current_type and topic.entity_id=:nid
			  and referencing.entity_id!=:rnid
			  and referencing.bundle=:bundle
			  and node.status=1";
	$results = db_query($sql, [
		'current_type'=>$current_type,
		'nid' =>$node['#node']->nid,
		'rnid'=>$node['#node']->nid,
		'bundle'=>$bundle
	]);

	return cob_load_nodes_from_results($results);
}

/**
 * @param string $type The type of nodes to return
 * @param int $limit
 * @return array An array of node objects
 */
function cob_nodes_recent($type=null, $limit=10)
{
	$limit = (int)$limit;
	if ($type) {
		$sql = "select nid from node where status=1 and type=:type order by created desc limit $limit";
		$results = db_query($sql, ['type'=>$type]);
	}
	else {
		$sql = "select nid from node where status=1 order by created desc limit $limit";
		$results = db_query($sql);
	}
	return cob_load_nodes_from_results($results);
}

/**
 * Hydrates node objects from database results
 *
 * @param object $results A db_query object that has results
 * @return array An array of node objects
 */
function cob_load_nodes_from_results($results)
{
	$nids = array();
	foreach ($results as $row) {
		$nids[] = $row->nid;
	}
	$nodes = node_load_multiple($nids);
	return $nodes;
}

/**
 * Returns a parent node that has a logo
 *
 * This will iterate over all the possible node references
 * and return a reference to one of them that actually has a logo.
 * This is useful for rendering a logo from a node reference
 * when the current node does not have a logo defined on itself.
 *
 * @return object The node object
 */
function cob_logo_parent($node_id)
{
	$fields = ['program', 'department', 'board_or_commission', 'location'];
	foreach ($fields as $f) {
		$sql = "select f.field_{$f}_target_id
				from field_data_field_$f f
				join field_data_field_logo l on l.entity_type='node' and f.field_{$f}_target_id=l.entity_id
				where f.entity_type='node' and f.entity_id=?";
		$pid = db_query($sql, array($node_id))->fetchField();
		if ($pid) {
			return node_load($pid);
		}
	}
}


/**
 * @param int $program_node_id
 * @return db_results
 */
function cob_upcoming_events($program_node_id=null)
{
	$sql = "select
				dates.entity_id as event_node_id,
				min(dates.field_date_value) as date,
				node.title,
				program.field_program_target_id as program_node_id
			from field_data_field_date dates
			join node on dates.entity_id=node.nid
			left join field_data_field_program program on dates.entity_id=program.entity_id
			where dates.field_date_value >= now()";
	if ($program_node_id) {
		$sql.= ' and program.field_program_target_id='.(int)$program_node_id;
	}
	$sql.= " group by dates.entity_id order by date";

	return db_query($sql);
}

/**
 * @implements hook_filter_info()
 */
function cob_filter_info()
{
	return [
		'ureport' => [
			'title'            => 'Open311 client syntax',
			'description'      => 'Embeds the open311-proxy client',
			'process callback' => '_cob_ureport_filter'
		],
		'toc' => [
			'title'            => 'Table of Contents',
			'description'      => 'Converts {toc} into a set of anchor links to header tags in the content',
			'process callback' => '_cob_toc_filter'
		]
	];
}

/**
 * @param string $url
 * @return string
 */
function cob_http_get($url)
{
    $session = curl_init($url);
    curl_setopt($session, CURLOPT_HEADER,         false);
    curl_setopt($session, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($session, CURLOPT_FOLLOWLOCATION, true);
    if (substr($url, 0, 5) == 'https') {
        curl_setopt($session, CURLOPT_SSL_VERIFYHOST, false);
        curl_setopt($session, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($session, CURLOPT_SSLVERSION, 3);
    }
    return curl_exec($session);
}

/**
 * Returns contact information for a department
 *
 * We store the official contact information in Active Directory
 * This function requests data from the Directory web application's
 * restful web service.
 *
 * @param string $dn The DN for the department
 * @return stdClass The JSON object from the response
 */
function cob_department_info($dn)
{
    $url = 'http://apps.bloomington.in.gov/directory/departments/view?format=json;dn='.urlencode($dn);
    $json = cob_http_get($url);
    return json_decode($json);
}


function _cob_ureport_filter($text, $filter, $format, $langcode, $cache, $cache_id)
{
	$open311Proxy = 'https://bloomington.in.gov/open311-proxy';

	$ureportMarkup = "
	<script type=\"text/javascript\">
		function handleHeightResponse(e) {
			document.getElementById('open311Client').height = parseInt(e.data + 60);
		}
		if (window.addEventListener) {
			window.addEventListener('message', handleHeightResponse, false);
		}
	</script>
	<iframe id=\"open311Client\"
			src=\"$open311Proxy/embed?\${1}\"
			height=\"720\"
			onload=\"this.contentWindow.postMessage('height','$open311Proxy');\"></iframe>
	";

	return preg_replace('/{open311:(.+)}/', $ureportMarkup, $text);
}

function _cob_toc_filter($text, $filter, $format, $langcode, $cache, $cache_id)
{
	$parameters = [];

	if (preg_match('/\{toc\}/', $text, $matches)) {
        $toc = _cob_create_toc($text, 2, 6);
        return preg_replace('/\{toc\}/', $toc['toc'], $toc['content']);
	}
	return $text;
}

/**
 * Generates markup for table of contents anchors in the provided content
 *
 * The input content is modified.  We have to add ID attributes to the H
 * tags we are going to anchor to.
 * This function will return the HTML for the TOC as well as
 * the modified HTML based on the original content provided.
 *
 * @param string $content HTML content to create a TOC for
 * @param int $min The minimum H value to look for
 * @param int $max The maximum H value to look for
 * @return array [toc=>$htmlstring, content=>$htmlstring]
 */
function _cob_create_toc($content, $min=1, $max=6) {
	$min = (int)$min;
	$max = (int)$max;

	$anchors = [];
	$toc 	 = '<ol>';
	$i 		 = 0;

	preg_match_all( "/<h([$min-$max])(.*)>([^<]+)<\/h[$min-$max]>/i", $content, $matches, PREG_SET_ORDER );

	if (!count($matches)) { return ['toc'=>null, 'content'=>$content]; }

	foreach ($matches as $heading) {
		$lvl        = $heading[1];
		$attributes = $heading[2];
		$title      = $heading[3];

		if ($i == 0) { $startlvl = $lvl; }

		$ret = preg_match( '/id=[\'|"](.*)?[\'|"]/i', stripslashes($attributes), $anchor);
		if ($ret && $anchor[1] != '') {
			$anchor = stripslashes($anchor[1]);
			$add_id = false;
		} else {
			$anchor = preg_replace('/\s+/', '-', preg_replace('/[^a-z\s]/', '', strtolower($title)));
			$add_id = true;
		}

		if (!in_array($anchor, $anchors)) { $anchors[] = $anchor; }
		else {
			$orig_anchor = $anchor;
			$i = 2;
			while (in_array($anchor, $anchors)) {
				$anchor = $orig_anchor.'-'.$i;
				$i++;
			}
			$anchors[] = $anchor;
		}

		if ($add_id) {
			$content = substr_replace(
				$content,
				"<h$lvl id=\"$anchor\"$attributes>$title</h$lvl>",
				strpos($content, $heading[0]),
				strlen($heading[0])
			);
		}

		$title = trim(strip_tags($title));

		if ($i > 0) {
			if ($prevlvl < $lvl) { $toc .= "<ol>"; }
			else if ($prevlvl > $lvl) {
				$toc .= '</li>';
				while ($prevlvl > $lvl) {
					$toc .= "</ol></li>";
					$prevlvl--;
				}
			}
			else { $toc .= '</li>'; }
		}

		$j = 0;
		$toc .= "<li><a href=\"#$anchor\">$title</a>";
		$prevlvl = $lvl;

		$i++;
	}

	unset($anchors);

	while ($lvl > $startlvl) {
		$toc .= "</ol>";
		$lvl--;
	}

	$toc .= '</li>';
	$toc .= '</ol>';

	return ['toc'=>$toc, 'content'=>$content];
}
