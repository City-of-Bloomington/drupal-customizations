<?php
/**
 * @copyright 2013-2015 City of Bloomington, Indiana
 * @license http://www.gnu.org/licenses/agpl.txt GNU/AGPL, see LICENSE.txt
 * @author Cliff Ingham <inghamn@bloomington.in.gov>
 */
/**
 * @see http://www.drupalcontrib.org/api/drupal/contributions!libraries!libraries.api.php/function/hook_libraries_info/7
 * @implements hook_libraries_info()
 */
function cob_libraries_info()
{
    return ['google-api-php-client' => [
        'name'         => 'Google API PHP Client',
        'vendor url'   => 'https://github.com/google/google-api-php-client',
        'download url' => 'https://github.com/google/google-api-php-client/archive/master.zip',
        'version callback' => 'cob_version_check',
        'files' => [
            'php' => ['src/Google/autoload.php']
        ]
    ]];
}

/**
 * Right now we do not care about version.
 * Any version of the google_api will do
 */
function cob_version_check() { return true; }

/**
 * Defines routes and callbacks for this module
 *
 * @implements hook_menu
 * @see https://api.drupal.org/api/drupal/modules!system!system.api.php/function/hook_menu/7
 */
function cob_menu()
{
    return [
        'directory/departments' => [
            'title'            => 'Department Staff Directory',
            'description'      => 'Contact information for a department',
            'page callback'    => '_cob_directory',
            'access arguments' => ['access content']
        ],
        'directory' => [
            'title'            => 'Staff Directory',
            'description'      => 'Lists contact information from Directory webservice',
            'page callback'    => '_cob_directory',
            'access arguments' => ['access content']
        ],
        'rectrac/%' => [
            'title'            => 'Parks and Recreation Activities',
            'description'      => 'Displays a single activity from RecTrac',
            'page callback'    => '_cob_rectrac_activity',
            'page arguments'   => [1],
            'access arguments' => ['access content']
        ]
    ];
}
include __DIR__.'/cob_directory.php';
include __DIR__.'/cob_rectrac.php';
include __DIR__.'/cob_calendars.php';

/**
 * Describes custom templates used by this module
 *
 * @implements hook_theme()
 * @see https://www.drupal.org/node/933976
 * @see https://api.drupal.org/api/drupal/modules!system!system.api.php/function/hook_theme/7
 */
function cob_theme()
{
    $path = drupal_get_path('module', 'cob');
    return [
        'cob_directory' => [
            'path'      => $path,
            'template'  => 'cob_directory',
            'variables' => ['departments'=>null]
        ],
        'cob_directory_listing' => [
            'path'      => $path,
            'template'  => 'cob_directory_listing',
            'variables' => ['department'=>null]
        ],
        'cob_rectrac_activity' => [
            'path'      => $path,
            'template'  => 'cob_rectrac_activity',
            'variables' => ['activity'=>null]
        ]
    ];
}

/**
 * Override other module's theme information
 *
 * We're using this to use our own template for attachments.
 * Attachments are handled by the cmisro module (which talks
 * to Alfresco).
 *
 * @implements hook_theme_registry_alter
 * @param array $theme_registry The entire cache of theme registry information, post-processing.
 * @see https://api.drupal.org/api/drupal/modules!system!system.api.php/function/hook_theme_registry_alter/7
 */
function cob_theme_registry_alter(&$theme_registry)
{
    $theme_registry['cmisro_object']['path'] = drupal_get_path('theme', 'cob').'/templates';
}

/**
 * Fetches useful book information
 *
 * Looks up the parent node information for a book.
 *
 * @param array $book The book information from the node object
 * @return stdClass
 */
function cob_book_info(&$book)
{
    $sql = "select b.nid, n.type, n.title, c.field_category_tid
            from book b
            join node n on b.nid=n.nid
            left join field_data_field_category c on b.nid=c.entity_id
            where b.mlid=?";
    $query = db_query($sql, [$book['plid']]);
    $results = $query->fetchAll();
    if ($results) {
        return current($results);
    }
}

/**
 * Return nodes attached to a term
 *
 * This is a replacement for the official taxonomy_select_nodes function
 * The official function does not support ordering alphabetically
 *
 * @override taxonomy_select_nodes
 * @see https://api.drupal.org/api/drupal/modules!taxonomy!taxonomy.module/function/taxonomy_select_nodes/7
 */
function cob_taxonomy_nodes($tid)
{
    $sql = "select t.nid from taxonomy_index t
            join node n on t.nid=n.nid
            where t.tid=?
            order by n.title";
    $query = db_query($sql, [$tid]);
    $results = $query->fetchAll();
    if ($results) {
        return cob_load_nodes_from_results($results);
    }
}

/**
 * Returns nodes of the given type that refer to the given node
 *
 * Important:
 * This relies on having set up entity reference fields
 * that exactly match the machine names of content types.
 *
 * Pass in the current node and specify what type of related nodes
 * you're looking for.  Content type for $bundle must have a
 * field reference to the content type of the current node.
 *
 * The $bundle type nodes might be in a hiearchy.  In that case,
 * you can also specify if you want only the top level nodes of
 * that content type.  By default, nodes from any level in the
 * hiearchy will be returned.
 *
 * @param array  $node   The current node
 * @param string $bundle The content type of nodes to return
 * @param string $order  The ordering for returned nodes (alphabetical, chronological)
 * @param int    $limit  How many nodes to return
 * @param bool   $top_level_only
 * @return array An array of node objects
 */
function cob_node_references(array &$node, $bundle, $top_level_only=false, $order=null, $limit=null)
{
	// All the rest of the field references can only reference one node
	// However, nodes that reference topics can link to unlimited topics
	// So, the fieldname for the topic references is plural
	$nid          = $node['nid'];
	$current_type = $node['type'];

	if ($current_type == 'topic') { $current_type.= 's'; }

	$field_table  = "field_data_field_$current_type";

	if (db_table_exists($field_table)) {
		$sql =     "select referencing.entity_id as nid from $field_table referencing
					  join node on referencing.entity_id=node.nid
					 where referencing.field_{$current_type}_target_id=?
					   and referencing.bundle='$bundle'
					   and node.status=1";
		if ($order) {
			switch ($order) {
				case 'alphabetical':
					$sql.= " order by node.title";
				break;

				case 'chronological':
					$sql.= " order by node.created desc";
				break;
			}
		}
		$limit = (int)$limit;
		if ($limit) {
			$sql.= " limit $limit";
		}

		$results = db_query($sql, [$nid]);
		if ($top_level_only) {
			# Filter our references that have ancestors that also reference the current node
			$r = $results->fetchAllAssoc('nid');
			foreach (array_keys($r) as $reference_id) {
				if (cob_node_reference_has_parent($nid, $reference_id, $bundle, $current_type)) {
					unset($r[$reference_id]);
				}
			}
			$results = $r;
		}

		return cob_load_nodes_from_results($results);
	}
}

/**
 * Check for an ancestor that also references the current node
 *
 * Checks to see if a node-reference has an ancestor that also references
 * the same current node.  This assumes that you have already called
 * cob_node_references to get the full list of nodes that reference the
 * current node.
 *
 * Any ancestor that references the current node should be in the results
 * from that function.  So, we just need to iterate over the results
 * @return bool
 */
function cob_node_reference_has_parent($current_id, $child_id, $parent_bundle, $current_bundle )
{
	$sql = "select field_{$parent_bundle}_target_id as parent_id,r.field_{$current_bundle}_target_id as target
			from field_data_field_{$parent_bundle} p
			left join field_data_field_{$current_bundle} r on p.field_{$parent_bundle}_target_id=r.entity_id and r.field_{$current_bundle}_target_id=?
			where p.entity_id=?";
	$results = db_query($sql, array($current_id, $child_id));
	$r = $results->fetchAll();
	if (isset($r[0])) {
		//echo "Found a parent for this {$parent_bundle}\n";
		if ($r[0]->target) {
			//echo "Parent references the current node\n";
			return true;
		}
		else {
			//echo "We should check for more ancenstors\n";
			return cob_node_reference_has_parent($current_id, $r[0]->parent_id, $parent_bundle, $current_bundle);
		}
	}
	//echo "No more parents found\n";
}

/**
 * Hydrates node objects from database results
 *
 * @param object $results A db_query object that has results
 * @return array An array of node objects
 */
function cob_load_nodes_from_results($results)
{
	$nids = array();
	foreach ($results as $row) {
		$nids[] = $row->nid;
	}
	$nodes = node_load_multiple($nids);
	return $nodes;
}

/**
 * @param int $program_node_id
 * @return db_results
 */
function cob_upcoming_events($program_node_id=null)
{
	$sql = "select
				dates.entity_id as event_node_id,
				min(dates.field_date_value) as date,
				node.title,
				program.field_program_target_id as program_node_id
			from field_data_field_date dates
			join node on dates.entity_id=node.nid
			left join field_data_field_program program on dates.entity_id=program.entity_id
			where dates.field_date_value >= now()";
	if ($program_node_id) {
		$sql.= ' and program.field_program_target_id='.(int)$program_node_id;
	}
	$sql.= " group by dates.entity_id order by date";

	return db_query($sql);
}

/**
 * @implements hook_filter_info()
 * @see https://api.drupal.org/api/drupal/modules%21filter%21filter.api.php/function/hook_filter_info/7
 */
function cob_filter_info()
{
	return [
		'ureport' => [
			'title'            => 'Open311 client syntax',
			'description'      => 'Embeds the open311-proxy client',
			'process callback' => '_cob_ureport_filter'
		],
		'toc' => [
			'title'            => 'Table of Contents',
			'description'      => 'Converts {toc} into a set of anchor links to header tags in the content',
			'process callback' => '_cob_toc_filter'
		],
		'internal_links' => [
            'title'            => 'Internal Links',
            'description'      => 'Allows node/XX style links to always use the correct base url and alias, if avaiable',
            'process callback' => '_cob_internal_links_filter'
		]

	];
}

/**
 * @param string $url
 * @return string
 */
function cob_http_get($url)
{
    $session = curl_init($url);
    curl_setopt($session, CURLOPT_HEADER,         false);
    curl_setopt($session, CURLOPT_RETURNTRANSFER, true);
    curl_setopt($session, CURLOPT_FOLLOWLOCATION, true);
    if (substr($url, 0, 5) == 'https') {
        curl_setopt($session, CURLOPT_SSL_VERIFYHOST, false);
        curl_setopt($session, CURLOPT_SSL_VERIFYPEER, false);
    }
    return curl_exec($session);
}

/**
 * @implements callback_filter_process()
 * @see https://api.drupal.org/api/drupal/modules!filter!filter.api.php/function/callback_filter_process/7
 */
function _cob_internal_links_filter($text, $filter, $format, $langcode, $cache, $cache_id)
{
    return preg_replace_callback(
        '/\[(.+)?\]\((node\/\d+)\)/',
        function ($matches) {
            return l($matches[1], $matches[2]);
        },
        $text
    );
}

/**
 * @implements callback_filter_process()
 * @see https://api.drupal.org/api/drupal/modules!filter!filter.api.php/function/callback_filter_process/7
 */
function _cob_ureport_filter($text, $filter, $format, $langcode, $cache, $cache_id)
{
    $open311Proxy = variable_get('cob_open311_uri');

	$ureportMarkup = "
	<script type=\"text/javascript\">
		function handleHeightResponse(e) {
			document.getElementById('open311Client').height = parseInt(e.data + 60);
		}
		if (window.addEventListener) {
			window.addEventListener('message', handleHeightResponse, false);
		}
	</script>
	<iframe id=\"open311Client\"
			class=\"cob-open311Client\"
			src=\"$open311Proxy/embed?\${1}\"
			height=\"720\"
			onload=\"this.contentWindow.postMessage('height','$open311Proxy');\"></iframe>
	";

	return preg_replace('/{open311:(.+)}/', $ureportMarkup, $text);
}

/**
 * @implements callback_filter_process()
 * @see https://api.drupal.org/api/drupal/modules!filter!filter.api.php/function/callback_filter_process/7
 */
function _cob_toc_filter($text, $filter, $format, $langcode, $cache, $cache_id)
{
	$parameters = [];

	if (preg_match('/\{toc\}/', $text, $matches)) {
        $toc = _cob_create_toc($text, 2, 6);
        return preg_replace('/\{toc\}/', $toc['toc'], $toc['content']);
	}
	return $text;
}

/**
 * Generates markup for table of contents anchors in the provided content
 *
 * The input content is modified.  We have to add ID attributes to the H
 * tags we are going to anchor to.
 * This function will return the HTML for the TOC as well as
 * the modified HTML based on the original content provided.
 *
 * @param string $content HTML content to create a TOC for
 * @param int $min The minimum H value to look for
 * @param int $max The maximum H value to look for
 * @return array [toc=>[anchor=>title], content=>$htmlstring]
 */
function _cob_create_toc($content, $min=1, $max=6) {
	$min = (int)$min;
	$max = (int)$max;

	$anchors = [];
	$toc 	 = [];

	preg_match_all( "/<h([$min-$max])(.*)>([^<]+)<\/h[$min-$max]>/i", $content, $matches, PREG_SET_ORDER );

	if (!count($matches)) { return ['toc'=>null, 'content'=>$content]; }

	foreach ($matches as $heading) {
		$lvl        = $heading[1];
		$attributes = $heading[2];
		$title      = $heading[3];

		$ret = preg_match( '/id=[\'|"](.*)?[\'|"]/i', stripslashes($attributes), $anchor);
		if ($ret && $anchor[1] != '') {
			$anchor = stripslashes($anchor[1]);
			$add_id = false;
		} else {
			$anchor = preg_replace('/\s+/', '-', preg_replace('/[^a-z\s]/', '', strtolower($title)));
			$add_id = true;
		}

		// Add numbers to make duplicate anchors unique
		if (!in_array($anchor, $anchors)) { $anchors[] = $anchor; }
		else {
			$orig_anchor = $anchor;
			$i = 2;
			while (in_array($anchor, $anchors)) {
				$anchor = $orig_anchor.'-'.$i;
				$i++;
			}
			$anchors[] = $anchor;
		}

		// Add the ID attribute to the anchor headings
		if ($add_id) {
			$content = substr_replace(
				$content,
				"<h$lvl id=\"$anchor\"$attributes>$title</h$lvl>",
				strpos($content, $heading[0]),
				strlen($heading[0])
			);
		}

		$title = trim(strip_tags($title));

		$toc[$anchor] = $title;
	}

	return ['toc'=>$toc, 'content'=>$content];
}
